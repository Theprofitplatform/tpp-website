class ServiceAnimations { constructor() { this.cards = []; this.observers = new Map(); this.isReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches; this.init(); } init() { if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => this.setupAnimations()); } else { this.setupAnimations(); } } setupAnimations() { this.cards = document.querySelectorAll('.service-card'); if (this.cards.length === 0) { console.warn('No service cards found'); return; } this.setupIntersectionObserver(); this.setupHoverOptimizations(); this.setupPerformanceMonitoring(); this.setupTouchOptimizations(); console.log(`Initialized animations for ${this.cards.length} service cards`); } setupIntersectionObserver() { if (this.isReducedMotion) { this.cards.forEach(card => card.classList.add('animate-in')); return; } const options = { root: null, rootMargin: '-10% 0px -10% 0px', threshold: [0.1, 0.5, 0.9] }; const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { const card = entry.target; if (entry.isIntersecting && entry.intersectionRatio >= 0.1) { this.animateCardEntrance(card); observer.unobserve(card); } }); }, options); this.cards.forEach(card => { observer.observe(card); }); this.observers.set('entrance', observer); } animateCardEntrance(card) { card.classList.add('animate-in'); const icon = card.querySelector('.service-icon'); if (icon) { setTimeout(() => { icon.classList.add('animate-in'); }, 200); } const features = card.querySelectorAll('.service-features li'); features.forEach((feature, index) => { setTimeout(() => { feature.style.opacity = '1'; feature.style.transform = 'translateX(0)'; }, 300 + (index * 100)); }); card.dispatchEvent(new CustomEvent('serviceCardAnimated', { detail: { card, timestamp: Date.now() } })); } setupHoverOptimizations() { this.cards.forEach(card => { let hoverTimeout; card.addEventListener('mouseenter', () => { if (this.isReducedMotion) return; clearTimeout(hoverTimeout); requestAnimationFrame(() => { card.style.willChange = 'transform, box-shadow'; this.triggerHoverEffects(card, true); }); }); card.addEventListener('mouseleave', () => { if (this.isReducedMotion) return; hoverTimeout = setTimeout(() => { requestAnimationFrame(() => { card.style.willChange = 'auto'; this.triggerHoverEffects(card, false); }); }, 50); }); card.addEventListener('focusin', () => { if (!this.isReducedMotion) { this.triggerHoverEffects(card, true); } }); card.addEventListener('focusout', () => { if (!this.isReducedMotion) { this.triggerHoverEffects(card, false); } }); }); } triggerHoverEffects(card, isHovering) { const icon = card.querySelector('.service-icon'); const title = card.querySelector('h3'); const description = card.querySelector('p'); const features = card.querySelectorAll('.service-features li'); const button = card.querySelector('.service-cta .btn'); if (isHovering) { card.classList.add('card-hovering'); features.forEach((feature, index) => { setTimeout(() => { feature.style.transform = 'translateX(5px)'; }, index * 30); }); if (icon && !this.isReducedMotion) { icon.style.animation = 'none'; setTimeout(() => { icon.style.animation = 'iconHover 0.6s ease-out'; }, 10); } } else { card.classList.remove('card-hovering'); features.forEach(feature => { feature.style.transform = 'translateX(0)'; }); if (icon) { icon.style.animation = ''; } } } setupPerformanceMonitoring() { let frameCount = 0; let lastTime = performance.now(); const measureFPS = () => { frameCount++; const currentTime = performance.now(); if (currentTime - lastTime >= 1000) { const fps = Math.round((frameCount * 1000) / (currentTime - lastTime)); if (fps < 30) { this.enablePerformanceMode(); } frameCount = 0; lastTime = currentTime; } requestAnimationFrame(measureFPS); }; if (!this.isReducedMotion) { requestAnimationFrame(measureFPS); } } enablePerformanceMode() { console.log('Enabling performance mode - reducing animation complexity'); document.body.classList.add('performance-mode'); this.cards.forEach(card => { card.style.willChange = 'auto'; const shimmer = card.querySelector('::before'); if (shimmer) { card.style.setProperty('--shimmer-enabled', '0'); } }); } setupTouchOptimizations() { const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0; if (isTouchDevice) { document.body.classList.add('touch-device'); this.cards.forEach(card => { card.addEventListener('touchstart', () => { if (!this.isReducedMotion) { card.classList.add('touch-active'); } }, { passive: true }); card.addEventListener('touchend', () => { setTimeout(() => { card.classList.remove('touch-active'); }, 150); }, { passive: true }); card.style.setProperty('--hover-enabled', '0'); }); } } pauseAnimations() { document.body.classList.add('animations-paused'); this.cards.forEach(card => { card.style.animationPlayState = 'paused'; }); } resumeAnimations() { document.body.classList.remove('animations-paused'); this.cards.forEach(card => { card.style.animationPlayState = 'running'; }); } refreshAnimations() { this.cleanup(); this.setupAnimations(); } cleanup() { this.observers.forEach(observer => observer.disconnect()); this.observers.clear(); this.cards.forEach(card => { card.classList.remove('animate-in', 'card-hovering', 'touch-active'); card.style.willChange = 'auto'; }); } static isAnimationSupported() { return 'animate' in document.createElement('div') && 'IntersectionObserver' in window && 'requestAnimationFrame' in window; } } const additionalKeyframes = ` @keyframes iconHover { 0% { transform: scale(1.15) rotate(8deg); } 25% { transform: scale(1.18) rotate(10deg); } 50% { transform: scale(1.15) rotate(6deg); } 75% { transform: scale(1.17) rotate(9deg); } 100% { transform: scale(1.15) rotate(8deg); } } .performance-mode .service-card { transition-duration: 0.2s !important; } .performance-mode .service-card::before { display: none !important; } .touch-device .service-card:hover { transform: none !important; } .touch-active { transform: scale(0.98) !important; transition-duration: 0.1s !important; } .animations-paused * { animation-play-state: paused !important; } `; function injectStyles() { const style = document.createElement('style'); style.textContent = additionalKeyframes; document.head.appendChild(style); } let serviceAnimations; function initServiceAnimations() { if (ServiceAnimations.isAnimationSupported()) { injectStyles(); serviceAnimations = new ServiceAnimations(); window.serviceAnimations = serviceAnimations; } else { console.warn('Service animations not supported in this browser'); document.querySelectorAll('.service-card').forEach(card => { card.style.opacity = '1'; card.style.transform = 'none'; }); } } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initServiceAnimations); } else { initServiceAnimations(); } document.addEventListener('visibilitychange', () => { if (serviceAnimations) { if (document.hidden) { serviceAnimations.pauseAnimations(); } else { serviceAnimations.resumeAnimations(); } } }); const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)'); mediaQuery.addEventListener('change', (e) => { if (serviceAnimations) { serviceAnimations.isReducedMotion = e.matches; if (e.matches) { serviceAnimations.pauseAnimations(); } else { serviceAnimations.resumeAnimations(); } } }); if (typeof module !== 'undefined' && module.exports) { module.exports = ServiceAnimations; }