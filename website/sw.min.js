const CACHE_NAME = 'tpp-v1.0.0'; const CRITICAL_CACHE = 'tpp-critical-v1.0.0'; const CRITICAL_RESOURCES = [ '/', '/css/critical.min.css', '/js/combined.min.js', '/favicon.ico' ]; const STATIC_RESOURCES = [ '/css/style.min.css', '/about.html', '/services.html', '/contact.html', '/portfolio.html' ]; const EXTERNAL_RESOURCES = [ 'https: 'https: ]; self.addEventListener('install', event => { event.waitUntil( Promise.all([ caches.open(CRITICAL_CACHE).then(cache => cache.addAll(CRITICAL_RESOURCES)), caches.open(CACHE_NAME).then(cache => cache.addAll(STATIC_RESOURCES)) ]).then(() => self.skipWaiting()) ); }); self.addEventListener('activate', event => { event.waitUntil( caches.keys().then(cacheNames => { return Promise.all( cacheNames.map(cacheName => { if (cacheName !== CACHE_NAME && cacheName !== CRITICAL_CACHE) { return caches.delete(cacheName); } }) ); }).then(() => self.clients.claim()) ); }); self.addEventListener('fetch', event => { const { request } = event; const url = new URL(request.url); if (request.method !== 'GET') { return; } if (url.origin !== location.origin && !isFontRequest(request)) { return; } if (isCriticalResource(request)) { event.respondWith(cacheFirst(request, CRITICAL_CACHE)); } else if (isStaticResource(request)) { event.respondWith(cacheFirst(request, CACHE_NAME)); } else if (isFontRequest(request)) { event.respondWith(cacheFirst(request, CACHE_NAME, { maxAge: 31536000 })); } else if (isImageRequest(request)) { event.respondWith(cacheFirst(request, CACHE_NAME, { maxAge: 2592000 })); } else if (isHTMLRequest(request)) { event.respondWith(networkFirst(request, CACHE_NAME)); } else { event.respondWith(networkFirst(request, CACHE_NAME)); } }); async function cacheFirst(request, cacheName, options = {}) { try { const cachedResponse = await caches.match(request); if (cachedResponse) { if (options.maxAge) { const cacheDate = new Date(cachedResponse.headers.get('date')); const now = new Date(); const ageInSeconds = (now - cacheDate) / 1000; if (ageInSeconds > options.maxAge) { updateCache(request, cacheName); } } return cachedResponse; } const networkResponse = await fetch(request); if (networkResponse.ok) { const cache = await caches.open(cacheName); cache.put(request, networkResponse.clone()); } return networkResponse; } catch (error) { const cachedResponse = await caches.match(request); if (cachedResponse) { return cachedResponse; } throw error; } } async function networkFirst(request, cacheName) { try { const networkResponse = await fetch(request); if (networkResponse.ok) { const cache = await caches.open(cacheName); cache.put(request, networkResponse.clone()); } return networkResponse; } catch (error) { const cachedResponse = await caches.match(request); if (cachedResponse) { return cachedResponse; } throw error; } } async function updateCache(request, cacheName) { try { const networkResponse = await fetch(request); if (networkResponse.ok) { const cache = await caches.open(cacheName); cache.put(request, networkResponse.clone()); } } catch (error) { console.warn('Failed to update cache for:', request.url); } } function isCriticalResource(request) { const url = request.url; return CRITICAL_RESOURCES.some(resource => url.includes(resource)) || url.includes('critical.min.css') || url.includes('combined.min.js'); } function isStaticResource(request) { const url = request.url; return url.includes('.css') || url.includes('.js') || url.includes('.woff') || url.includes('.woff2') || url.includes('.ttf') || url.includes('.eot'); } function isFontRequest(request) { const url = request.url; return url.includes('fonts.googleapis.com') || url.includes('fonts.gstatic.com') || url.includes('.woff') || url.includes('.woff2') || url.includes('.ttf') || url.includes('.eot'); } function isImageRequest(request) { const url = request.url; return url.includes('.jpg') || url.includes('.jpeg') || url.includes('.png') || url.includes('.webp') || url.includes('.svg') || url.includes('.gif') || url.includes('images/') || url.includes('storage.googleapis.com'); } function isHTMLRequest(request) { const url = request.url; return request.headers.get('accept').includes('text/html') || url.endsWith('.html') || (!url.includes('.') && !url.includes('api/')); } self.addEventListener('sync', event => { if (event.tag === 'form-submission') { event.waitUntil(handleFormSync()); } }); async function handleFormSync() { const submissions = await getStoredSubmissions(); for (const submission of submissions) { try { await fetch(submission.url, { method: 'POST', headers: submission.headers, body: submission.body }); await removeStoredSubmission(submission.id); } catch (error) { console.warn('Failed to sync form submission:', error); } } } async function getStoredSubmissions() { return []; } async function removeStoredSubmission(id) { return true; } self.addEventListener('push', event => { if (!event.data) return; const data = event.data.json(); const options = { body: data.body, icon: '/favicon-192x192.png', badge: '/favicon-32x32.png', tag: 'tpp-notification', requireInteraction: false, actions: data.actions || [] }; event.waitUntil( self.registration.showNotification(data.title || 'The Profit Platform', options) ); }); self.addEventListener('notificationclick', event => { event.notification.close(); event.waitUntil( clients.matchAll({ type: 'window' }).then(clientList => { for (const client of clientList) { if (client.url === '/' && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow('/'); } }) ); }); self.addEventListener('message', event => { if (event.data && event.data.type === 'PERFORMANCE_MEASURE') { console.log('Performance metrics:', event.data.metrics); } }); setInterval(() => { cleanupOldCaches(); }, 24 * 60 * 60 * 1000); async function cleanupOldCaches() { const cacheWhitelist = [CACHE_NAME, CRITICAL_CACHE]; const cacheNames = await caches.keys(); return Promise.all( cacheNames.map(cacheName => { if (!cacheWhitelist.includes(cacheName)) { return caches.delete(cacheName); } }) ); }